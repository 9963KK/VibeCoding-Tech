# Vibe 文档自动同步机制

## 🎯 设计目标

确保代码变更与文档始终保持一致，通过**自动检测 + 强制检查**的方式，避免文档滞后。

---

## 📐 同步机制架构

```
代码变更 → 变更分析器 → 触发规则匹配 → 生成文档更新任务 → 开发者确认 → 文档更新 → 验证同步
   ↓           ↓              ↓                 ↓              ↓           ↓          ↓
 [Commit]   [AI分析]     [匹配规则表]      [待办清单]      [人工审核]   [PR]    [CI检查]
```

---

## 🔍 阶段一：变更检测与分析

### 1.1 自动变更检测
在以下时机触发检测：
- **Git commit前**: Pre-commit hook检查
- **PR创建时**: GitHub Actions自动分析
- **代码合并后**: Post-merge hook检查

### 1.2 变更分析器

#### 检测规则表

| 变更类型 | 检测条件 | 需要更新的文档 | 示例 |
|---------|---------|--------------|------|
| **新增模块** | 新增目录包含 index.ts/main.py 等入口文件 | 规划文档 - 模块协作矩阵 | `src/modules/auth/` |
| **API变更** | 文件包含路由定义 (@GetMapping, @Post, etc) | API文档、接口契约 | `@Post('/api/users')` |
| **数据库Schema** | 包含 CREATE TABLE, ALTER TABLE | 数据模型文档 | `CREATE TABLE users` |
| **配置项新增** | 修改 .env.example, config.yaml | 配置说明文档 | `DATABASE_URL=...` |
| **用户可见功能** | 前端页面新增 (src/pages/) | README、用户手册 | `src/pages/Login.tsx` |
| **技术栈引入** | package.json 新增依赖 | 规划文档 - 技术架构层 | `"redis": "^4.0.0"` |
| **架构决策** | tech-spec/目录下新增ADR | 规划文档 - ADR索引 | `tech-spec/ADR-001.md` |

#### 检测脚本示例 (Git Hook)

```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "🔍 检查是否需要更新文档..."

# 检测API变更
if git diff --cached --name-only | grep -E "routes/|controllers/" > /dev/null; then
  echo "⚠️  检测到API变更，请确认是否需要更新API文档"
  echo "   受影响的文件:"
  git diff --cached --name-only | grep -E "routes/|controllers/"
  echo ""
  echo "   需要更新: docs/api.md"
  echo ""

  read -p "是否已更新相关文档? (y/n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "❌ 请先更新文档后再提交"
    exit 1
  fi
fi

# 检测数据库变更
if git diff --cached --name-only | grep -E "migrations/|schema.sql" > /dev/null; then
  echo "⚠️  检测到数据库变更，请确认是否需要更新数据模型文档"

  read -p "是否已更新数据模型文档? (y/n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "❌ 请先更新文档后再提交"
    exit 1
  fi
fi

# 检测新模块
if git diff --cached --name-status | grep "^A" | grep -E "src/modules/.*/index" > /dev/null; then
  echo "⚠️  检测到新模块，请确认是否需要更新规划文档"

  read -p "是否已更新规划文档? (y/n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "❌ 请先更新规划文档后再提交"
    exit 1
  fi
fi

echo "✅ 文档同步检查通过"
```

---

## 📋 阶段二：生成文档更新任务

### 2.1 自动生成待办清单

当检测到需要更新文档时，自动在功能清单中添加待办项：

```markdown
### ✅ 实现TODO
- [x] 实现用户认证API
- [x] 编写单元测试
- [ ] 📄 更新API文档 (自动检测到API变更)
- [ ] 📄 更新规划文档 - 模块协作矩阵 (自动检测到新模块)
```

### 2.2 文档更新提示模板

**API文档更新提示**:
```markdown
## 📄 需要更新API文档

检测到以下API变更:
- 新增路由: POST /api/v1/users
- 修改路由: GET /api/v1/users/:id

请在以下文档中更新:
- [ ] docs/api.md - 添加新接口说明
- [ ] docs/api-contracts.md - 更新接口契约

参考格式:
\`\`\`markdown
## POST /api/v1/users
创建新用户

### 请求体
\`\`\`json
{
  "username": "string",
  "email": "string"
}
\`\`\`

### 响应
\`\`\`json
{
  "id": "string",
  "username": "string"
}
\`\`\`
\`\`\`
```

**规划文档更新提示**:
```markdown
## 📄 需要更新规划文档

检测到新增模块: AuthModule

请在规划文档中更新:
- [ ] 模块协作矩阵 - 添加新行
- [ ] 架构图 - 更新模块依赖关系

模块信息模板:
| 模块名 | 依赖模块 | 提供能力 | 通信方式 | 数据契约 |
|--------|---------|---------|---------|---------|
| AuthModule | UserModule, EmailModule | JWT认证 | REST API | AuthDTO |
```

---

## ✅ 阶段三：文档更新执行

### 3.1 文档更新检查清单

每次更新文档时，遵循以下检查清单：

#### API文档更新
- [ ] 接口路径正确
- [ ] 请求方法正确 (GET/POST/PUT/DELETE)
- [ ] 请求参数完整（路径参数、查询参数、请求体）
- [ ] 响应格式完整（成功响应、错误响应）
- [ ] 错误码列表完整
- [ ] 包含示例请求和响应
- [ ] 认证要求已说明
- [ ] 权限要求已说明

#### 规划文档更新
- [ ] 模块名称清晰
- [ ] 模块职责描述符合SRP（单一职责）
- [ ] 依赖关系准确
- [ ] 通信方式明确
- [ ] 数据契约定义清晰
- [ ] 架构图已更新（如使用Mermaid）

#### 配置文档更新
- [ ] 配置项名称准确
- [ ] 默认值已说明
- [ ] 可选值范围已说明
- [ ] 环境差异已说明（dev/staging/prod）
- [ ] 敏感配置的安全提示已添加

#### README更新
- [ ] 新功能在功能列表中已列出
- [ ] 如有新依赖，已更新安装说明
- [ ] 如有新命令，已更新使用说明
- [ ] 截图/GIF已更新（UI变更时）

### 3.2 文档更新PR模板

```markdown
## 📄 文档更新PR

### 关联变更
- 代码PR: #123
- 功能清单: #FEATURE-XXX

### 更新内容
- [ ] API文档
- [ ] 规划文档
- [ ] 配置文档
- [ ] README
- [ ] CHANGELOG

### 变更说明
[详细描述文档变更内容]

### 一致性检查
- [ ] 文档与代码实现一致
- [ ] 示例代码可运行
- [ ] 链接有效
- [ ] 术语统一
- [ ] 格式规范
```

---

## 🤖 阶段四：自动化验证

### 4.1 CI自动检查

在CI/CD流水线中添加文档一致性检查：

```yaml
# .github/workflows/doc-sync-check.yml
name: Documentation Sync Check

on:
  pull_request:
    branches: [main]

jobs:
  check-doc-sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整历史以分析变更

      - name: 检测API变更
        run: |
          if git diff origin/main...HEAD --name-only | grep -E "routes/|controllers/"; then
            echo "::warning::检测到API变更"

            # 检查API文档是否同步更新
            if ! git diff origin/main...HEAD --name-only | grep "docs/api.md"; then
              echo "::error::API变更但未更新API文档"
              exit 1
            fi
          fi

      - name: 检测数据库变更
        run: |
          if git diff origin/main...HEAD --name-only | grep -E "migrations/|schema.sql"; then
            if ! git diff origin/main...HEAD --name-only | grep "docs/data-model.md"; then
              echo "::error::数据库变更但未更新数据模型文档"
              exit 1
            fi
          fi

      - name: 检测新模块
        run: |
          NEW_MODULES=$(git diff origin/main...HEAD --name-status | grep "^A" | grep -E "src/modules/.*/index" || true)
          if [ ! -z "$NEW_MODULES" ]; then
            if ! git diff origin/main...HEAD --name-only | grep "docs/architecture.md"; then
              echo "::error::新增模块但未更新规划文档"
              exit 1
            fi
          fi

      - name: 检查CHANGELOG
        run: |
          # 如果有功能变更，CHANGELOG必须更新
          if git diff origin/main...HEAD --name-only | grep -E "src/|lib/"; then
            if ! git diff origin/main...HEAD --name-only | grep "CHANGELOG.md"; then
              echo "::error::代码变更但未更新CHANGELOG"
              exit 1
            fi
          fi
```

### 4.2 文档链接检查

定期检查文档中的链接有效性：

```yaml
# .github/workflows/doc-links-check.yml
name: Documentation Links Check

on:
  schedule:
    - cron: '0 0 * * 0'  # 每周日运行
  workflow_dispatch:

jobs:
  check-links:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: 检查Markdown链接
        uses: gaurav-nelson/github-action-markdown-link-check@v1
        with:
          use-quiet-mode: 'yes'
          config-file: '.markdown-link-check.json'
```

### 4.3 API文档与代码一致性检查

使用工具自动比对API文档与实际代码:

```javascript
// scripts/check-api-doc-sync.js
const fs = require('fs');
const path = require('path');

// 从代码中提取所有API路由
function extractRoutesFromCode() {
  // 解析routes/目录下的所有文件
  // 提取所有@Get, @Post, @Put, @Delete装饰器
  // 返回: [{ method: 'GET', path: '/api/users', file: 'users.controller.ts' }]
}

// 从API文档中提取所有API
function extractRoutesFromDocs() {
  // 解析docs/api.md
  // 提取所有## GET /api/..., ## POST /api/...
  // 返回: [{ method: 'GET', path: '/api/users' }]
}

function compareRoutes() {
  const codeRoutes = extractRoutesFromCode();
  const docRoutes = extractRoutesFromDocs();

  // 找出只在代码中存在的路由
  const missingInDocs = codeRoutes.filter(cr =>
    !docRoutes.some(dr => dr.method === cr.method && dr.path === cr.path)
  );

  // 找出只在文档中存在的路由
  const missingInCode = docRoutes.filter(dr =>
    !codeRoutes.some(cr => cr.method === dr.method && cr.path === dr.path)
  );

  if (missingInDocs.length > 0) {
    console.error('❌ 以下API存在于代码但未在文档中:');
    missingInDocs.forEach(r => console.error(`   ${r.method} ${r.path} (${r.file})`));
  }

  if (missingInCode.length > 0) {
    console.error('❌ 以下API存在于文档但未在代码中:');
    missingInCode.forEach(r => console.error(`   ${r.method} ${r.path}`));
  }

  if (missingInDocs.length > 0 || missingInCode.length > 0) {
    process.exit(1);
  }

  console.log('✅ API文档与代码一致');
}

compareRoutes();
```

---

## 📊 阶段五：文档同步监控

### 5.1 文档新鲜度追踪

创建一个文档状态仪表板:

```markdown
# 文档健康度报告

| 文档 | 最后更新 | 关联代码最后变更 | 状态 | 滞后天数 |
|------|---------|----------------|------|---------|
| API文档 | 2024-01-10 | 2024-01-10 | ✅ 同步 | 0 |
| 规划文档 | 2024-01-08 | 2024-01-09 | ⚠️ 滞后 | 1 |
| 数据模型文档 | 2024-01-05 | 2024-01-10 | ❌ 严重滞后 | 5 |
| 配置说明 | 2024-01-09 | 2024-01-09 | ✅ 同步 | 0 |

## 告警规则
- ⚠️ 滞后 1-3天: 提醒更新
- ❌ 滞后 >3天: 阻断新PR合并
```

### 5.2 文档覆盖率统计

```markdown
# 文档覆盖率

## API文档覆盖率
- 代码中的API总数: 45
- 文档中的API总数: 42
- 覆盖率: 93.3%
- 缺失的API:
  - GET /api/v1/users/:id/profile
  - POST /api/v1/orders/:id/cancel
  - DELETE /api/v1/comments/:id

## 模块文档覆盖率
- 代码中的模块总数: 12
- 规划文档中的模块数: 11
- 覆盖率: 91.7%
- 缺失的模块:
  - NotificationModule
```

---

## 🛠️ 实施工具推荐

### 工具1: 文档生成工具
- **Swagger/OpenAPI**: 从代码注解自动生成API文档
- **TypeDoc/JSDoc**: 从代码注释生成代码文档
- **dbdocs.io**: 从数据库Schema生成文档

### 工具2: 文档校验工具
- **markdown-link-check**: 检查Markdown文档中的死链
- **vale**: 文档风格和术语一致性检查
- **alex**: 检查文档中的不当用语

### 工具3: 文档版本控制
- **Git**: 所有文档存储在代码仓库中
- **PR Review**: 文档变更必须经过Review
- **GitHub Wiki**: 用户手册等非技术文档

---

## 📋 完整文档同步检查清单

### PR合并前检查
- [ ] 所有自动检测的文档更新任务已完成
- [ ] CI文档同步检查通过
- [ ] 文档PR已合并（如单独PR）
- [ ] CHANGELOG已更新

### 定期检查 (每周)
- [ ] 运行文档新鲜度报告
- [ ] 检查文档覆盖率
- [ ] 修复滞后超过3天的文档
- [ ] 清理过时文档

### 发布前检查
- [ ] 所有文档与代码一致
- [ ] 所有文档链接有效
- [ ] API文档覆盖率 100%
- [ ] CHANGELOG包含所有变更

---

## 🎓 最佳实践

### 1. 文档即代码 (Docs as Code)
- 文档存储在代码仓库中
- 使用Git进行版本控制
- 通过PR进行文档变更
- CI/CD自动校验文档

### 2. 就近原则
- API文档靠近路由定义
- 组件文档靠近组件代码
- 使用内联注释 + 自动生成工具

### 3. 单一事实来源 (Single Source of Truth)
- 避免信息重复
- 使用引用而非复制
- 定义清晰的文档层次

### 4. 持续维护
- 设置文档负责人
- 定期Review文档质量
- 建立文档反馈机制

---

## 🚫 常见陷阱

❌ **陷阱1**: 文档更新作为可选项
- **后果**: 文档快速过期，失去参考价值
- **解决**: 将文档更新作为DoD的强制项

❌ **陷阱2**: 过度依赖人工检查
- **后果**: 容易遗漏，随着项目增大难以维持
- **解决**: 自动化检测 + 强制CI检查

❌ **陷阱3**: 文档与代码分离
- **后果**: 同步困难，容易不一致
- **解决**: 文档即代码，使用Git统一管理

❌ **陷阱4**: 文档更新滞后到"有空再说"
- **后果**: 永远没有"有空的时候"
- **解决**: 代码变更和文档更新在同一个PR中完成

---

## 📚 参考资源

- [Docs as Code 实践指南](https://www.writethedocs.org/guide/docs-as-code/)
- [API文档最佳实践](https://swagger.io/resources/articles/best-practices-in-api-documentation/)
- [技术写作风格指南](https://developers.google.com/style)
